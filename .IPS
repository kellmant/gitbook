#/!/bin/bash
# V3.141 - sysblog returns
#set -eo pipefail
#IFS=$'\n'
#shopt -s nullglob 
shopt -s checkwinsize
#need this to get the basic variables
set -a
overlay=$(curl -s http://169.254.169.254/latest/dynamic/instance-identity/document | jq -r '.region' | cut -d '-' -f 2- | tr -d '-')


# Normal Colors
Black='\e[0;30m'        # Black
Red='\e[0;31m'          # Red
Green='\e[0;32m'        # Green
Yellow='\e[0;33m'       # Yellow
Blue='\e[0;34m'         # Blue
Purple='\e[0;35m'       # Purple
Cyan='\e[0;36m'         # Cyan
White='\e[0;37m'        # White

# Bold
BBlack='\e[1;30m'       # Black
BRed="\e[1;31m"         # Red
BGreen='\e[1;32m'       # Green
BYellow='\e[1;33m'      # Yellow
BBlue='\e[1;34m'        # Blue
BPurple='\e[1;35m'      # Purple
BCyan='\e[1;36m'        # Cyan
BWhite='\e[1;37m'       # White

# Background
On_Black='\e[40m'       # Black
On_Red='\e[41m'         # Red
On_Green='\e[42m'       # Green
On_Yellow='\e[43m'      # Yellow
On_Blue='\e[44m'        # Blue
On_Purple='\e[45m'      # Purple
On_Cyan='\e[46m'        # Cyan
On_White='\e[47m'       # White

NC='\e[m'               # Color Reset

CKEY=${BBlue}
CVAL=${BGreen}

CCTRL=${BBlue}
CIPS=${BGreen}
CBOT=${BPurple}
CKILL=${BRed}
CINFO=${BYellow}
CHELP=${BCyan}

CBUILD=${BWhite}${On_Blue}
CREV=${BBlack}${On_White}
CBOLD=${BWhite}${On_Black}
CNORM=${White}${On_Black}
CALERT=${BWhite}${On_Red} # Bold White on red background
CWARN=${BBlack}${On_Yellow} # Bold White on red background
CGOOD=${BWhite}${On_Green} # Bold White on red background

# =============================================================== #
PROTO="http"
KEYHOST="${PROTO}://keystore:2379"
KEYSTORE="${KEYHOST}/v2/keys"
ETCDCTL_ENDPOINTS=${KEYHOST}
export ETCDCTL_ENDPOINTS
ipscmd="$(basename -- "$0")"
keycmd=$(echo "$ipscmd" | cut -d '-' -f 2-)
keyfunc=$(echo "$ipscmd" | cut -d '-' -f 1)
cmdenv="env/${keyfunc}/${keycmd}"
glbenv="env/global/${keycmd}"
prodenv="env/global/prod"
uatenv="env/global/uat"
devenv="env/global/dev"
crashenv="env/global/crash"
ipsenv="env/ips/${keycmd}"
ctrlenv="env/ctrl/${keycmd}"
trustedca="/ca/root/ca-chain.crt"
clientcrt="/ca/local/local.cert.pem"
clientkey="/ca/local/local.key.pem"
msgttl=86400
tstamp=$(date -u +%s)
cmdhost=$(hostname | cut -d '.' -f 1)

# we can use keystore or local var to manage the rest.
# your call.
#
KEYCURL="curl -s"

if [ "$PROTO" != "https" ] ; then
	restget="$KEYCURL -L"
	restput="$KEYCURL -XPUT"
	else
	restget="$KEYCURL --cacert ${trustedca} --cert ${clientcrt} --key ${clientkey} -L"
	restput="$KEYCURL --cacert ${trustedca} --cert ${clientcrt} --key ${clientkey} -XPUT"
	ETCDCTL_CA_FILE=$trustedca
	ETCDCTL_CERT_FILE=$clientcrt
	ETCDCTL_KEY_FILE=$clientkey
	export ETCDCTL_CA_FILE
	export ETCDCTL_CERT_FILE
	export ETCDCTL_KEY_FILE
fi
readrest="jq -r '.node.value'" 
	# watch a key keys/foo?wait=true
restwatch="wait=true"
	#detailed and recursive listing ?recursive=true&sorted=true'
restsort="sorted=true"
restrecurse="recursive=true&sorted=true"
ALLKEYS="$KEYCURL $KEYSTORE/?${restrecurse}"
ALLMSGS="$KEYCURL $KEYSTORE/stream?${restrecurse}"
	# store small files keys/afile -XPUT --data-urlencode value@afile.txt
reststore="--data-urlencode"
	#set ttl keys/foo?ttl=20 -d value=bar
	#set ttl on dir keys/dir -XPUT -d ttl=30 -d dir=true
	# directory with value
	# delete key curl -L -X DELETE http://127.0.0.1:2379/v2/keys/message
	# recursive del curl http://127.0.0.1:2379/v2/keys/dir?recursive=true -XDELETE
export ETCDCTL_STRICT_HOST_KEY_CHECKING=false
export FLEETCTL_STRICT_HOST_KEY_CHECKING=false
# add some general variables for our scripts

GETVAL () {
returnvalue=$(echo "$1" | jq -r '.node.value')
echo "$returnvalue"
}

# overide in the keystore, do not edit this file!
PULLKEY="$restget $KEYSTORE"
PULLENV="$PULLKEY/$ipsenv"
PUTKEY="$restput $KEYSTORE"
PUTJOB="$restput $KEYSTORE/jobs/run"
PUTENV="$PUTKEY/$ipsenv"
LISTKEYS="$($KEYCURL $KEYSTORE/?${restsort})"
KEYSTATS=$($KEYCURL $KEYHOST/v2/stats/store)
DELKEY="curl -L -X DELETE $KEYSTORE"
# 
#
#tail -F /path/to/serverLog | while read ; do msgbus ; done &>>/dev/null &!
msgbus() {
    STREAMIT="$restput $KEYSTORE/stream"
	messagein="$@"
	tstamp=$(date +"%a %r")
	stamp=$$
	pidowner=$(whoami)
	ksig="[ $pidowner $BUDDY $stamp ]"
	tsecs=$(date +"%s")
	mhost=$(hostname)
	messageout="$mhost | $tstamp | ${messagein[@]} $ksig"
	eval "${STREAMIT} -d value=\"${messageout}\"" 1>/dev/null
}

# jobstart "$$"
# trap "jobtrace '$$'" 0 1 2 3 6
    
jobstart () {
    #etcdctl set jobs/run/$$ "$(date -u +%s)" 
	jobpid=$1
	jobtime=$(date -u +%s)
	eval $PUTJOB/${jobpid} -d value=\"$jobtime\" 
	}

jobtrace () {
jobpid=$1
jobstartr=`$PULLKEY/jobs/run/${jobpid}`
jobstart=$(GETVAL "$jobstartr")
jobstop=$(date -u +%s)
(( jobtime = jobstop - jobstart ))
jobdir=$(pwd)
jobinfo=$(basename "$jobdir")
eval $PUTKEY/jobs/done/${jobinfo}.${ipscmd} -d value=\"PID:$jobpid runtime $(($jobtime/3600)) hours $(($jobtime%3600/60)) minutes and $(($jobtime%60)) seconds\"
msgbus "${ipscmd} job ${jobinfo} completed in $(($jobtime/3600)) hours $(($jobtime%3600/60)) minutes and $(($jobtime%60)) seconds"
eval $DELKEY/jobs/run/${jobpid}
}

# add some general functions for our scripts

u_confirm() {
    while true; do
        read -r -n 1 -p "${1:-Continue?} [y/n]: " REPLY
        case $REPLY in
            [0]) echo ; return 0 ;;
            [1]) echo ; return 1 ;;
            [q]) echo "smell ya later" ; exit 254 ;;
            [y]) printf " \033[31m %s \n\033[0m" "Yes on a binary decision? To the machine is that a ONE or ZERO $BUD ?";;
            [n]) printf " \033[31m %s \n\033[0m" "No on a binary decision? To the machine is that a ONE or ZERO $BUD ?";;
            [h]) printf " \033[31m %s \n\033[0m" "Looking for help? return code 1 means an error to the machine, where as 0 represents a successful exit code. So what do you think now $BUD ? Which return code would tell the machine to proceed? 1 or 0 ? ";;
            *) printf " \033[31m %s \n\033[0m" "Actually, looking for a 1 or 0 return code to proceed or cancel. What is YES or NO $BUD in binary form? Try h for help or make your choice between 1 or 0 and use that key."
        esac
    done
}


msgsms () {
    inmsg="$@"
    topic=$(etcdctl get usr/${BUDDY}/arn) || { return 1 ; }
    aws sns publish --topic-arn "${topic}" --message "${inmsg}" &>/dev/null
}

get_ops () {
    if [ -z $1 ] ; then
        return 1
    fi
    unset ${COREARRAY[@]}
    cnt=0
    INKEYS=($(etcdctl ls --sort --recursive ops/${1}))
    for (( i=0; i<${#INKEYS[@]}; i++ )) ; do
        tfile="${INKEYS[$i]}"
        element=$(echo ${tfile} | cut -d '/' -f 4-)
        vals=$(etcdctl get $tfile 2>/dev/null)
        if [ $? -eq 0 ] ; then
            (( cnt++ ))
            COREARRAY+=("${vals}")
        else
            continue
        fi
    done
    echo "${COREARRAY[@]}"
}

get_corehosts () {
    unset ${LOCALARRAY[@]}
    cnt=0
    INKEYS=($(etcdctl ls --sort ops/registry))
    for (( i=0; i<${#INKEYS[@]}; i++ )) ; do
        tfile="${INKEYS[$i]}"
        element=$(echo ${tfile} | cut -d '/' -f 4)
            (( cnt++ ))
            LOCALARRAY+=("${element}")
    done
    echo "${LOCALARRAY[@]}"
}


submit_job () {
    if [ -z $1 ] ; then
        return
    fi
    jobcmd="$@"
	tstamp=$(date +"%s")
    etcdctl set --ttl 3800 jobs/start/${tstamp} "${jobcmd}"
}
    
get_regions () {
	aws ec2 describe-regions | jq -r '.Regions[].RegionName'
}

get_instances () {
        REGIONS=($(get_regions))
		for (( r=0; r<${#REGIONS[@]}; r++ )) ; do 
            Instances=($(aws ec2 --region ${REGIONS[$r]} describe-instances | jq -r .Reservations[].Instances[].InstanceId))
		        for (( i=0; i<${#Instances[@]}; i++ )) ; do 
	                getdef=$(aws ec2 describe-instances --region ${REGIONS[$r]} --instance-ids ${Instances[$i]} | jq '.Reservations[].Instances[]')
	                declare -A myarray 
                        while IFS="=" read -r key value ; do 
	                        myarray[$key]="$value" 
                        done < <(echo "${getdef[@]}" | jq -cr 'to_entries | map("\(.key)=\(.value)") | flatten[]') 
	                        for key in "${!myarray[@]}" ;  do 
		                        etcdctl set runtime/${Instances[$i]}}/$key "${myarray[$key]}"
                        done
               done
        done
}

set_host () {
    if [ -z $3 ] ; then
        return
    fi
    mkdir -p $HOME/names
    stage="$1"
    dhost="$2"
    IP="$3"
    dnsid=$(etcdctl get env/global/$1) 
    zoneid=$(etcdctl get zone/${dnsid}.) 
    dns=/$HOME/names/DNS.${dhost}.${dnsid}
    msgbus "dns injection to resolve $dhost.${dnsid} to $IP"
echo "{" > $dns
echo "      \"Comment\": \"${dhost}.${dnsid} DNS UPSERT\"," >> $dns
echo "      \"Changes\": [" >> $dns
echo "      {" >> $dns
echo "\"Action\": \"UPSERT\"," >> $dns
echo "\"ResourceRecordSet\": {" >> $dns
echo "\"Name\": \"${host}.${dnsid}\"," >> $dns
echo "\"Type\": \"A\"," >> $dns
echo "\"TTL\": 60," >> $dns
echo "\"ResourceRecords\": [" >> $dns
echo "     {" >> $dns
echo "\"Value\": \"$IP\"" >> $dns
echo "       }" >> $dns
echo "      ]" >> $dns
echo "     }" >> $dns
echo "    }" >> $dns
echo "   ]" >> $dns
echo "  }" >> $dns

aws route53 change-resource-record-sets --hosted-zone-id $zoneid --change-batch file://$dns
}


dns_rm () {
    dhost="$1"
    findname=($(ls -1 $HOME/names/DNS.${dhost}.*)) || { msgbus "$ipscmd found no dns record for $dhost moving on." ;  }
        for (( d=0; d<${#findname[@]}; d++ )) ; do
            dnsrr="${findname[$d]}"
            dnsid=$(echo "$dnsrr" | cut -d '.' -f 3-)
            zoneid=$(etcdctl get zone/${dnsid}.) 
            msgbus "${TAGKILL} dns record removal of $dhost.${dnsid} "
            sed -i "s/UPSERT/DELETE/g" $dnsrr
            aws route53 change-resource-record-sets --hosted-zone-id $zoneid --change-batch file://$dnsrr
            sleep 2
            rm -rf $dnsrr
        done
    }


ls_regions () {
	QARR=($(etcdctl ls --sort env/az))
	for (( r=0; r<${#QARR[@]}; r++ )) ; do 
		region=$(echo "${QARR[$r]}" | cut -d '/' -f 5)
        echo "$region"
        done
}

rnd_region () {
	QARR=($(etcdctl ls --sort aws))
	for (( r=0; r<${#QARR[@]}; r++ )) ; do 
		region=$(echo "${QARR[$r]}" | cut -d '/' -f 4)
    		AZONES=($(aws ec2 describe-availability-zones --region $region | jq -r '.AvailabilityZones[].ZoneName'))
    		#AZARR=()
    		for i in "${AZONES[@]}" ; do
    			az="${i: -1}"
    			loc=$(echo ${i} | cut -d '-' -f 2)
    			region="${i: -1}"
    			azs=("${loc}${region}")
    		done
    		AZARR+=( "$i" )
	done
#	echo "${AZARR[@]}"
	MYAZ=${AZARR[ $(( RANDOM % ${#AZARR[@]} )) ]}
	echo "${MYAZ}"
}















